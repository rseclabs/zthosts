#!/usr/bin/env python3
"""zthosts - Generate Linux hosts file entries from ZeroTier network members."""

import os
import re
import sys
import argparse
from datetime import datetime, timezone

import requests

BASE_URL = "https://api.zerotier.com/api/v1"
DEFAULT_OUTPUT = "./zt-hosts"
REQUEST_TIMEOUT = 10


def get_token(cli_token=None):
    """Read the ZeroTier API token from CLI arg or environment."""
    token = cli_token or os.environ.get("ZTNET_API_TOKEN")
    if not token:
        print(
            "Error: No API token provided.\n"
            "Supply your ZeroTier Central API token using one of:\n"
            "  1. CLI argument:          zthosts.py -t YOUR_TOKEN\n"
            "  2. Environment variable:  export ZTNET_API_TOKEN=YOUR_TOKEN\n\n"
            "Get your token at https://my.zerotier.com/account",
            file=sys.stderr,
        )
        sys.exit(1)
    return token


def get_headers(token):
    """Return authorization headers for the ZeroTier API."""
    return {"Authorization": f"token {token}"}


def fetch_networks(token):
    """Fetch all networks from the ZeroTier Central API."""
    resp = requests.get(
        f"{BASE_URL}/network", headers=get_headers(token), timeout=REQUEST_TIMEOUT
    )
    if not resp.ok:
        print(
            f"Error fetching networks: {resp.status_code} {resp.reason}",
            file=sys.stderr,
        )
        sys.exit(1)
    return resp.json()


def fetch_members(token, network_id):
    """Fetch all members of a specific network."""
    resp = requests.get(
        f"{BASE_URL}/network/{network_id}/member",
        headers=get_headers(token),
        timeout=REQUEST_TIMEOUT,
    )
    if not resp.ok:
        print(
            f"Error fetching members for network {network_id}: "
            f"{resp.status_code} {resp.reason}",
            file=sys.stderr,
        )
        sys.exit(1)
    return resp.json()


def select_network(networks):
    """Interactively prompt the user to select a network."""
    if not networks:
        print("No networks found.", file=sys.stderr)
        sys.exit(1)

    print("\nAvailable ZeroTier Networks:")
    print("-" * 50)
    for i, net in enumerate(networks, 1):
        name = net.get("config", {}).get("name", "unnamed")
        nid = net.get("id", "unknown")
        members = net.get("totalMemberCount", 0)
        print(f"  [{i}] {name} ({nid}) - {members} members")
    print()

    while True:
        try:
            choice = input("Select a network [1]: ").strip()
            if not choice:
                choice = "1"
            idx = int(choice) - 1
            if 0 <= idx < len(networks):
                return networks[idx]
            print(f"Please enter a number between 1 and {len(networks)}.")
        except (ValueError, EOFError):
            print(f"Please enter a number between 1 and {len(networks)}.")
        except KeyboardInterrupt:
            print("\nAborted.")
            sys.exit(130)


def sanitize_name(name):
    """Sanitize a member name for use in a hosts file."""
    name = name.strip().lower()
    name = name.replace(" ", "-")
    name = re.sub(r"[^a-z0-9\-.]", "", name)
    name = re.sub(r"-+", "-", name)
    name = name.strip("-.")
    return name


def build_hosts_entries(members, authorized_only=True):
    """Build hosts file lines from a list of members.

    Returns a list of (ip, name) tuples.
    """
    entries = []
    for member in members:
        config = member.get("config", {})
        if authorized_only and not config.get("authorized", False):
            continue

        raw_name = member.get("name", "")
        if not raw_name:
            continue

        name = sanitize_name(raw_name)
        if not name:
            continue

        ip_assignments = config.get("ipAssignments", [])
        if not ip_assignments:
            continue

        for ip in ip_assignments:
            entries.append((ip, name))

    entries.sort(key=lambda e: e[1])
    return entries


def format_hosts_file(entries, network_name, network_id):
    """Format the complete hosts file content with header and entries."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    lines = [
        "# ZeroTier Hosts - Generated by zthosts",
        f"# Network: {network_name} ({network_id})",
        f"# Generated: {timestamp}",
        f"# Members: {len(entries)}",
        "",
    ]
    for ip, name in entries:
        lines.append(f"{ip}\t{name}")
    lines.append("")
    return "\n".join(lines)


def parse_args():
    """Parse command-line arguments."""
    epilog = """\
examples:
  # Set token via environment variable, then run interactively
  export ZTNET_API_TOKEN=your_token_here
  python zthosts.py

  # Pass token directly on the command line
  python zthosts.py -t your_token_here

  # Skip interactive selection with a known network ID
  python zthosts.py -t your_token_here -n abc1234567

  # Write to a custom file
  python zthosts.py -o /etc/zt-hosts

  # Print to stdout only (no file written)
  python zthosts.py --stdout-only

API token:
  Get your ZeroTier Central API token at https://my.zerotier.com/account
  Provide it via -t/--token or the ZTNET_API_TOKEN environment variable.
"""
    parser = argparse.ArgumentParser(
        description="Generate a Linux hosts file from ZeroTier network members.",
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-t",
        "--token",
        help="ZeroTier API token (or set ZTNET_API_TOKEN env var)",
    )
    parser.add_argument(
        "-n",
        "--network-id",
        help="ZeroTier network ID (skip interactive selection)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default=DEFAULT_OUTPUT,
        help=f"Output file path (default: {DEFAULT_OUTPUT})",
    )
    parser.add_argument(
        "--stdout-only",
        action="store_true",
        help="Print to stdout only, skip file write",
    )
    parser.add_argument(
        "--all-members",
        action="store_true",
        help="Include unauthorized members (default: authorized only)",
    )
    return parser.parse_args()


def main():
    args = parse_args()
    token = get_token(args.token)

    # Determine network
    if args.network_id:
        network_id = args.network_id
        # Fetch networks to get the name for the header
        networks = fetch_networks(token)
        network = next((n for n in networks if n.get("id") == network_id), None)
        if network:
            network_name = network.get("config", {}).get("name", "unknown")
        else:
            network_name = "unknown"
    else:
        networks = fetch_networks(token)
        network = select_network(networks)
        network_id = network["id"]
        network_name = network.get("config", {}).get("name", "unknown")

    # Fetch and process members
    members = fetch_members(token, network_id)
    authorized_only = not args.all_members
    entries = build_hosts_entries(members, authorized_only=authorized_only)

    # Build output
    content = format_hosts_file(entries, network_name, network_id)

    # Write to file
    if not args.stdout_only:
        with open(args.output, "w") as f:
            f.write(content)
        print(content, end="")
        print(f"\n# Wrote {len(entries)} host entries to {args.output}", file=sys.stderr)
    else:
        print(content, end="")
        print(f"\n# {len(entries)} host entries", file=sys.stderr)


if __name__ == "__main__":
    main()
